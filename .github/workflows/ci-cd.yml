name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  PROJECT_ID: ${{ vars.PROJECT_ID || 'perplexity-clone-468820' }}
  REGION: ${{ vars.REGION || 'us-central1' }}
  BACKEND_SERVICE: perplexity-clone-backend
  FRONTEND_SERVICE: perplexity-clone-frontend
  ARTIFACT_REGISTRY: ${{ vars.REGION || 'us-central1' }}-docker.pkg.dev
  REPOSITORY_NAME: perplexity-clone-repository


jobs:
  # Backend CI/CD
  backend:
    name: Backend CI/CD
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Cache Python dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install Python dependencies
      run: |
        cd backend
        pip install -r requirements.txt
        pip install pytest pytest-asyncio httpx
        
    - name: Run backend tests
      run: |
        cd backend
        python -m pytest tests/ -v --tb=short
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Google Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet
        
    - name: Build and push backend image
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        platforms: linux/amd64
        tags: |
          ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:${{ github.sha }}
          ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
  # Frontend CI/CD
  frontend:
    name: Frontend CI/CD
    runs-on: ubuntu-latest
    needs: [backend]  # Wait for backend to build first
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci --prefer-offline --no-audit
        
    - name: Run frontend tests
      run: |
        cd frontend
        npm run test --if-present
        npm run lint --if-present
        
    - name: Build frontend
      run: |
        cd frontend
        npm run build
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Google Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet
        
    - name: Get backend URL for build
      id: backend-url
      run: |
        gcloud config set run/region ${{ env.REGION }}
        BACKEND_URL=$(gcloud run services describe ${{ env.BACKEND_SERVICE }} --region=${{ env.REGION }} --format="value(status.url)" 2>/dev/null || echo "")
        
        if [ -z "$BACKEND_URL" ]; then
          echo "âš ï¸  Backend service not found, using placeholder URL for build"
          echo "backend-url=https://placeholder-backend-url.run.app" >> $GITHUB_OUTPUT
        else
          echo "âœ… Backend URL found: $BACKEND_URL"
          echo "backend-url=$BACKEND_URL" >> $GITHUB_OUTPUT
        fi
        
    - name: Build and push frontend image
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        platforms: linux/amd64
        build-args: |
          NEXT_PUBLIC_API_URL=${{ steps.backend-url.outputs.backend-url }}
        tags: |
          ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:${{ github.sha }}
          ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Infrastructure deployment and service updates
  deploy:
    name: Deploy Infrastructure and Update Services
    runs-on: ubuntu-latest
    needs: [backend, frontend]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.7"
        
    - name: Google Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Terraform Init
      run: |
        cd infrastructure
        terraform init
        
    - name: Terraform Plan
      run: |
        cd infrastructure
        terraform plan -var="backend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:${{ github.sha }}" \
                      -var="frontend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:${{ github.sha }}" \
                      -var="environment=${{ github.event.inputs.environment || 'dev' }}"
        
    - name: Terraform Apply
      run: |
        cd infrastructure
        
        # Apply Terraform changes - this will update both infrastructure and services
        terraform apply -auto-approve \
          -var="backend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:${{ github.sha }}" \
          -var="frontend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:${{ github.sha }}" \
          -var="environment=${{ github.event.inputs.environment || 'dev' }}"
        
    - name: Verify Terraform Deployment
      run: |
        cd infrastructure
        
        # Verify that Terraform has successfully updated the services
        echo "Verifying Terraform deployment..."
        terraform show | grep -A 5 -B 5 "CORS_ORIGINS"
        
        # Get the current service URLs from Terraform
        BACKEND_URL=$(terraform output -raw backend_url)
        FRONTEND_URL=$(terraform output -raw frontend_url)
        
        echo "Backend URL: $BACKEND_URL"
        echo "Frontend URL: $FRONTEND_URL"
        
        # Store URLs for verification job
        echo "backend-url=$BACKEND_URL" >> $GITHUB_ENV
        echo "frontend-url=$FRONTEND_URL" >> $GITHUB_ENV
        
        # Environment variables are now handled at build time via Docker build args
        # No need for complex runtime environment variable management
        echo "âœ… Environment variables handled at build time"

  # Post-deployment verification
  verification:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Google Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Resolve live service URLs
      id: urls
      run: |
        gcloud config set run/region ${{ env.REGION }}
        BACKEND_URL=$(gcloud run services describe ${{ env.BACKEND_SERVICE }} --region=${{ env.REGION }} --format="value(status.url)")
        FRONTEND_URL=$(gcloud run services describe ${{ env.FRONTEND_SERVICE }} --region=${{ env.REGION }} --format="value(status.url)")
        echo "backend-url=$BACKEND_URL"   >> $GITHUB_OUTPUT
        echo "frontend-url=$FRONTEND_URL" >> $GITHUB_OUTPUT
        echo "Resolved Backend:  $BACKEND_URL"
        echo "Resolved Frontend: $FRONTEND_URL"

    - name: Verify readiness (public)
      run: |
        FRONTEND_URL="${{ steps.urls.outputs.frontend-url }}"
        BACKEND_URL="${{ steps.urls.outputs.backend-url }}"
        echo "Frontend (expect 200): $FRONTEND_URL"
        curl -fsS "$FRONTEND_URL" >/dev/null
        echo "Backend (expect 403 unauth): $BACKEND_URL/health"
        code=$(curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL/health")
        [ "$code" = "403" ] || (echo "Expected 403, got $code" && exit 1)

    - name: Test backend functionality via service account
      run: |
        BACKEND_URL="${{ steps.urls.outputs.backend-url }}"
        echo "Testing backend functionality using service account authentication..."
        
        # Get an ID token for the current service account to authenticate with the backend
        echo "Getting ID token for backend authentication..."
        ID_TOKEN=$(gcloud auth print-identity-token --audiences="$BACKEND_URL")
        
        if [ -z "$ID_TOKEN" ]; then
          echo "âŒ Failed to get ID token"
          exit 1
        fi
        
        echo "âœ… Got ID token, testing backend endpoints..."
        
        # Test the health endpoint with authentication
        echo "Testing /health endpoint with authentication..."
        HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
          -H "Authorization: Bearer $ID_TOKEN" \
          "$BACKEND_URL/health")
        
        if [ "$HEALTH_STATUS" = "200" ]; then
          echo "âœ… Backend health endpoint working (200)"
        else
          echo "âŒ Backend health endpoint failed with status: $HEALTH_STATUS"
          exit 1
        fi
        
        # Test the API endpoint with authentication
        echo "Testing /api/v1/process-text endpoint with authentication..."
        API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
          -X POST \
          -H "Authorization: Bearer $ID_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"text":"test"}' \
          "$BACKEND_URL/api/v1/process-text")
        
        if [ "$API_STATUS" = "200" ]; then
          echo "âœ… Backend API endpoint working (200)"
        else
          echo "âŒ Backend API endpoint failed with status: $API_STATUS"
          exit 1
        fi
        
                echo "âœ… All backend functionality tests passed!"
        
        # Test CORS functionality
        echo "ðŸ” Testing CORS functionality..."
        CORS_TEST=$(curl -s -I -H "Origin: $FRONTEND_URL" -H "Access-Control-Request-Method: POST" -H "Access-Control-Request-Headers: Content-Type" "$BACKEND_URL/api/v1/process-text" | grep -i "access-control-allow-origin" || echo "No CORS headers in preflight")
        
        if echo "$CORS_TEST" | grep -q "access-control-allow-origin"; then
          echo "âœ… CORS preflight request working correctly"
        else
          echo "âš ï¸  CORS preflight request may have issues"
          echo "CORS Response: $CORS_TEST"
        fi
        
    - name: Verify build-time configuration
      run: |
        echo "Verifying that frontend was built with correct backend URL..."
        BACKEND_URL="${{ steps.urls.outputs.backend-url }}"
        FRONTEND_URL="${{ steps.urls.outputs.frontend-url }}"
        
        echo "ðŸ” Expected Configuration:"
        echo "Backend URL: $BACKEND_URL"
        echo "Frontend URL: $FRONTEND_URL"
        
        # Check backend environment variables (CORS configuration)
        echo "ðŸ” Checking backend CORS configuration..."
        BACKEND_ENV=$(gcloud run services describe ${{ env.BACKEND_SERVICE }} --region=${{ env.REGION }} \
          --format="value(spec.template.spec.containers[0].env)")
        
        echo "Raw backend environment variables: $BACKEND_ENV"
        
        # Check if CORS_ORIGINS is configured
        if echo "$BACKEND_ENV" | grep -q "CORS_ORIGINS"; then
          echo "âœ… CORS_ORIGINS is configured"
          
          # Extract the actual CORS_ORIGINS value
          CORS_ORIGINS=$(echo "$BACKEND_ENV" | sed -n "s/.*'CORS_ORIGINS', 'value': '\([^']*\)'.*/\1/p")
          if [ -n "$CORS_ORIGINS" ]; then
            echo "CORS_ORIGINS value: $CORS_ORIGINS"
            
            # Check if frontend URL is explicitly listed
            if echo "$CORS_ORIGINS" | grep -q "$FRONTEND_URL"; then
              echo "âœ… Frontend URL explicitly listed in CORS_ORIGINS"
            else
              echo "âš ï¸  Frontend URL not explicitly listed in CORS_ORIGINS"
              echo "Frontend URL: $FRONTEND_URL"
              echo "CORS_ORIGINS: $CORS_ORIGINS"
              echo "This may cause CORS issues!"
            fi
            
            # Test actual CORS headers
            echo "ðŸ” Testing CORS headers..."
            CORS_HEADERS=$(curl -s -I -H "Origin: $FRONTEND_URL" "$BACKEND_URL/health" | grep -i "access-control-allow-origin" || echo "No CORS headers found")
            echo "CORS Headers: $CORS_HEADERS"
            
            if echo "$CORS_HEADERS" | grep -q "access-control-allow-origin"; then
              echo "âœ… CORS headers are present"
            else
              echo "âŒ CORS headers are missing - this will cause CORS errors"
            fi
          else
            echo "âš ï¸  CORS_ORIGINS found but value could not be extracted"
          fi
        else
          echo "âŒ CORS_ORIGINS not set"
          exit 1
        fi
        
        echo "âœ… Backend CORS configuration verified"
        echo "âœ… Frontend built with correct backend URL (build-time configuration)"
        
    - name: Check Terraform state
      run: |
        echo "Checking Terraform state for environment variable configuration..."
        cd infrastructure
        
        # Check if Terraform is initialized
        if [ -f ".terraform/terraform.tfstate" ]; then
          echo "Local Terraform state found, checking configuration..."
          terraform show | grep -A 10 -B 5 "NEXT_PUBLIC_API_URL" || echo "NEXT_PUBLIC_API_URL not found in Terraform state"
        else
          echo "No local Terraform state found"
        fi
        
        # Check if there's a remote state
        if [ -f "terraform.tf" ] && grep -q "backend \"gcs\"" terraform.tf; then
          echo "Remote state configured, checking if backend is accessible..."
          terraform state list | head -5 || echo "Cannot access remote state"
        fi
        
        echo "If environment variables are missing, run: terraform apply -auto-approve"
        
    - name: Verify configuration
      run: |
        BACKEND_URL="${{ steps.urls.outputs.backend-url }}"
        FRONTEND_URL="${{ steps.urls.outputs.frontend-url }}"

        echo "Verifying service configuration..."
        echo "Expected Backend URL: $BACKEND_URL"
        echo "Expected Frontend URL: $FRONTEND_URL"
        
        # Frontend configuration verification
        echo "ðŸ” Frontend Configuration:"
        echo "âœ… Frontend is built with correct backend URL at build time"
        echo "âœ… No runtime NEXT_PUBLIC_API_URL environment variable needed"
        echo "âœ… Backend URL is embedded in the container image"
        
        # Verify the frontend can actually connect to the backend
        echo "ðŸ” Testing Frontend-Backend Connectivity:"
        echo "Frontend URL: $FRONTEND_URL"
        echo "Backend URL: $BACKEND_URL"
        
        # Check if frontend is accessible
        if curl -s -f "$FRONTEND_URL" > /dev/null; then
          echo "âœ… Frontend is accessible"
        else
          echo "âŒ Frontend is not accessible"
          exit 1
        fi
        
        # Check if backend is accessible (should return 403 for unauthorized)
        BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL/health")
        if [ "$BACKEND_STATUS" = "403" ]; then
          echo "âœ… Backend is accessible and properly secured (403 expected)"
        else
          echo "âš ï¸  Backend returned status $BACKEND_STATUS (expected 403)"
        fi
        
        echo "âœ… Frontend configuration verified (build-time configuration working)"

        # Backend CORS includes frontend URL (string match in env)
        echo "Checking backend CORS configuration..."
        BE_ENV=$(gcloud run services describe ${{ env.BACKEND_SERVICE }} --region=${{ env.REGION }} \
          --format="value(spec.template.spec.containers[0].env)")
        echo "Backend environment variables: $BE_ENV"
        
        # Check if CORS_ORIGINS is configured
        if echo "$BE_ENV" | grep -q "CORS_ORIGINS"; then
          echo "âœ… CORS_ORIGINS is configured"
          
          # Extract the actual CORS_ORIGINS value
          CORS_ORIGINS=$(echo "$BE_ENV" | sed -n "s/.*'CORS_ORIGINS', 'value': '\([^']*\)'.*/\1/p")
          if [ -n "$CORS_ORIGINS" ]; then
            echo "CORS_ORIGINS value: $CORS_ORIGINS"
            
            # Check if frontend URL is explicitly listed
            if echo "$CORS_ORIGINS" | grep -q "$FRONTEND_URL"; then
              echo "âœ… Frontend URL explicitly listed in CORS_ORIGINS"
            else
              echo "â„¹ï¸  Frontend URL not explicitly listed (wildcards may be used)"
              echo "Frontend URL: $FRONTEND_URL"
              echo "CORS_ORIGINS: $CORS_ORIGINS"
            fi
          else
            echo "âš ï¸  CORS_ORIGINS found but value could not be extracted"
          fi
        else
          echo "âŒ CORS_ORIGINS not set"
          exit 1
        fi

    - name: Create deployment summary
      run: |
        echo "## âœ… Post-Deployment Verification Passed" >> $GITHUB_STEP_SUMMARY
        echo "**Backend:** ${{ steps.urls.outputs.backend-url }}" >> $GITHUB_STEP_SUMMARY
        echo "**Frontend:** ${{ steps.urls.outputs.frontend-url }}" >> $GITHUB_STEP_SUMMARY
        echo "**Security:** Backend blocks unauth (403); passes with service account" >> $GITHUB_STEP_SUMMARY
        echo "**Functionality:** /health and /api/v1/process-text OK (authenticated)" >> $GITHUB_STEP_SUMMARY
        echo "**Config:** Build-time backend URL; CORS properly configured" >> $GITHUB_STEP_SUMMARY
