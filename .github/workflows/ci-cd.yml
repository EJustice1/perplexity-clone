name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  PROJECT_ID: ${{ vars.PROJECT_ID || 'perplexity-clone-468820' }}
  REGION: ${{ vars.REGION || 'us-central1' }}
  BACKEND_SERVICE: perplexity-clone-backend
  FRONTEND_SERVICE: perplexity-clone-frontend
  ARTIFACT_REGISTRY: ${{ vars.REGION || 'us-central1' }}-docker.pkg.dev
  REPOSITORY_NAME: perplexity-clone-repository


jobs:
  # Backend CI/CD
  backend:
    name: Backend CI/CD
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Cache Python dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install Python dependencies
      run: |
        cd backend
        pip install -r requirements.txt
        pip install pytest pytest-asyncio httpx
        
    - name: Run backend tests
      run: |
        cd backend
        python -m pytest tests/ -v --tb=short
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Google Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet
        
    - name: Build and push backend image
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        platforms: linux/amd64
        tags: |
          ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:${{ github.sha }}
          ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
  # Frontend CI/CD
  frontend:
    name: Frontend CI/CD
    runs-on: ubuntu-latest
    # Remove dependency on backend to run concurrently
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        
    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci --prefer-offline --no-audit
        
    - name: Run frontend tests
      run: |
        cd frontend
        npm run test --if-present
        npm run lint --if-present
        
    - name: Build frontend
      run: |
        cd frontend
        npm run build
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Google Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Configure Docker for Artifact Registry
      run: |
        gcloud auth configure-docker ${{ env.REGION }}-docker.pkg.dev --quiet
        
    - name: Build and push frontend image
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        platforms: linux/amd64
        tags: |
          ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:${{ github.sha }}
          ${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Infrastructure deployment and service updates
  deploy:
    name: Deploy Infrastructure and Update Services
    runs-on: ubuntu-latest
    needs: [backend, frontend]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.7"
        
    - name: Google Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        
    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Terraform Init
      run: |
        cd infrastructure
        terraform init
        
    - name: Terraform Plan
      run: |
        cd infrastructure
        terraform plan -var="backend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:${{ github.sha }}" \
                      -var="frontend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:${{ github.sha }}" \
                      -var="environment=${{ github.event.inputs.environment || 'dev' }}"
        
    - name: Terraform Apply
      run: |
        cd infrastructure
        
        # Apply Terraform changes - this will update both infrastructure and services
        terraform apply -auto-approve \
          -var="backend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:${{ github.sha }}" \
          -var="frontend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:${{ github.sha }}" \
          -var="environment=${{ github.event.inputs.environment || 'dev' }}"
        
    - name: Verify Terraform Deployment
      run: |
        cd infrastructure
        
        # Verify that Terraform has successfully updated the services
        echo "Verifying Terraform deployment..."
        terraform show | grep -A 5 -B 5 "CORS_ORIGINS"
        
        # Get the current service URLs from Terraform
        BACKEND_URL=$(terraform output -raw backend_url)
        FRONTEND_URL=$(terraform output -raw frontend_url)
        
        echo "Backend URL: $BACKEND_URL"
        echo "Frontend URL: $FRONTEND_URL"
        
        # Store URLs for verification job
        echo "backend-url=$BACKEND_URL" >> $GITHUB_ENV
        echo "frontend-url=$FRONTEND_URL" >> $GITHUB_ENV
        
        # Critical: Ensure environment variables are properly set
        echo "Checking if environment variables need to be reapplied..."
        
        # Check if NEXT_PUBLIC_API_URL is missing or incorrect in the deployed service
        FRONTEND_ENV_CHECK=$(gcloud run services describe ${{ env.FRONTEND_SERVICE }} --region=${{ env.REGION }} \
          --format="value(spec.template.spec.containers[0].env)" 2>/dev/null || echo "")
        
        if [ -n "$FRONTEND_ENV_CHECK" ]; then
          # Extract the actual NEXT_PUBLIC_API_URL value
          ACTUAL_API_URL=$(echo "$FRONTEND_ENV_CHECK" | sed -n "s/.*'NEXT_PUBLIC_API_URL', 'value': '\([^']*\)'.*/\1/p")
          
          if [ -z "$ACTUAL_API_URL" ] || [ "$ACTUAL_API_URL" != "$BACKEND_URL" ]; then
            echo "âš ï¸  Environment variables mismatch detected!"
            echo "Expected NEXT_PUBLIC_API_URL: $BACKEND_URL"
            echo "Found: $ACTUAL_API_URL"
            echo "Forcing Terraform reapply to fix environment variables..."
            
            # Force Terraform to update the service configuration
            terraform apply -auto-approve \
              -var="backend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:${{ github.sha }}" \
              -var="frontend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:${{ github.sha }}" \
              -var="environment=${{ github.event.inputs.environment || 'dev' }}"
            
            echo "âœ… Terraform reapplied to fix environment variables"
          else
            echo "âœ… Environment variables are correctly configured"
          fi
        else
          echo "âš ï¸  Could not check frontend environment variables, proceeding with verification"
        fi

  # Post-deployment verification
  verification:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Google Auth
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Setup Google Cloud CLI
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ env.PROJECT_ID }}
        
    - name: Resolve live service URLs
      id: urls
      run: |
        gcloud config set run/region ${{ env.REGION }}
        BACKEND_URL=$(gcloud run services describe ${{ env.BACKEND_SERVICE }} --region=${{ env.REGION }} --format="value(status.url)")
        FRONTEND_URL=$(gcloud run services describe ${{ env.FRONTEND_SERVICE }} --region=${{ env.REGION }} --format="value(status.url)")
        echo "backend-url=$BACKEND_URL"   >> $GITHUB_OUTPUT
        echo "frontend-url=$FRONTEND_URL" >> $GITHUB_OUTPUT
        echo "Resolved Backend:  $BACKEND_URL"
        echo "Resolved Frontend: $FRONTEND_URL"

    - name: Verify readiness (public)
      run: |
        FRONTEND_URL="${{ steps.urls.outputs.frontend-url }}"
        BACKEND_URL="${{ steps.urls.outputs.backend-url }}"
        echo "Frontend (expect 200): $FRONTEND_URL"
        curl -fsS "$FRONTEND_URL" >/dev/null
        echo "Backend (expect 403 unauth): $BACKEND_URL/health"
        code=$(curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL/health")
        [ "$code" = "403" ] || (echo "Expected 403, got $code" && exit 1)

    - name: Test backend functionality via service account
      run: |
        BACKEND_URL="${{ steps.urls.outputs.backend-url }}"
        echo "Testing backend functionality using service account authentication..."
        
        # Get an ID token for the current service account to authenticate with the backend
        echo "Getting ID token for backend authentication..."
        ID_TOKEN=$(gcloud auth print-identity-token --audiences="$BACKEND_URL")
        
        if [ -z "$ID_TOKEN" ]; then
          echo "âŒ Failed to get ID token"
          exit 1
        fi
        
        echo "âœ… Got ID token, testing backend endpoints..."
        
        # Test the health endpoint with authentication
        echo "Testing /health endpoint with authentication..."
        HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
          -H "Authorization: Bearer $ID_TOKEN" \
          "$BACKEND_URL/health")
        
        if [ "$HEALTH_STATUS" = "200" ]; then
          echo "âœ… Backend health endpoint working (200)"
        else
          echo "âŒ Backend health endpoint failed with status: $HEALTH_STATUS"
          exit 1
        fi
        
        # Test the API endpoint with authentication
        echo "Testing /api/v1/process-text endpoint with authentication..."
        API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
          -X POST \
          -H "Authorization: Bearer $ID_TOKEN" \
          -H "Content-Type: application/json" \
          -d '{"text":"test"}' \
          "$BACKEND_URL/api/v1/process-text")
        
        if [ "$API_STATUS" = "200" ]; then
          echo "âœ… Backend API endpoint working (200)"
        else
          echo "âŒ Backend API endpoint failed with status: $API_STATUS"
          exit 1
        fi
        
                echo "âœ… All backend functionality tests passed!"
        
    - name: Verify environment variables are persistent
      run: |
        echo "Verifying that environment variables persist after deployment..."
        BACKEND_URL="${{ steps.urls.outputs.backend-url }}"
        FRONTEND_URL="${{ steps.urls.outputs.frontend-url }}"
        
        echo "ðŸ” DEBUGGING: Expected URLs"
        echo "Backend URL: $BACKEND_URL"
        echo "Frontend URL: $FRONTEND_URL"
        
        # Check frontend environment variables
        echo "ðŸ” Checking frontend environment variables..."
        FRONTEND_ENV=$(gcloud run services describe ${{ env.FRONTEND_SERVICE }} --region=${{ env.REGION }} \
          --format="value(spec.template.spec.containers[0].env)")
        
        echo "Raw frontend environment variables: $FRONTEND_ENV"
        
        # Verify NEXT_PUBLIC_API_URL is set correctly
        ACTUAL_API_URL=$(echo "$FRONTEND_ENV" | sed -n "s/.*'NEXT_PUBLIC_API_URL', 'value': '\([^']*\)'.*/\1/p")
        echo "Extracted NEXT_PUBLIC_API_URL: '$ACTUAL_API_URL'"
        
                  if [ "$ACTUAL_API_URL" = "$BACKEND_URL" ]; then
            echo "âœ… Frontend NEXT_PUBLIC_API_URL correctly set: $ACTUAL_API_URL"
          else
            echo "âŒ Frontend NEXT_PUBLIC_API_URL mismatch or missing"
            echo "Expected: $BACKEND_URL"
            echo "Found: $ACTUAL_API_URL"
            
            # Additional debugging
            echo "ðŸ” Full environment variable dump:"
            gcloud run services describe ${{ env.FRONTEND_SERVICE }} --region=${{ env.REGION }} \
              --format="value(spec.template.spec.containers[0].env)" | jq -R 'fromjson? // .' 2>/dev/null || \
            gcloud run services describe ${{ env.FRONTEND_SERVICE }} --region=${{ env.REGION }} \
              --format="value(spec.template.spec.containers[0].env)"
            
            echo "ðŸš¨ CRITICAL: Environment variable mismatch detected!"
            echo "This will cause the frontend to fail in production."
            echo "Forcing Terraform reapply to fix this issue..."
            
            # Force Terraform to update the service configuration
            cd infrastructure
            terraform apply -auto-approve \
              -var="backend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/backend:${{ github.sha }}" \
              -var="frontend_image=${{ env.ARTIFACT_REGISTRY }}/${{ env.PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/frontend:${{ github.sha }}" \
              -var="environment=${{ github.event.inputs.environment || 'dev' }}"
            
            echo "âœ… Terraform reapplied. Checking if fix worked..."
            
            # Wait a moment for the service to update
            sleep 30
            
            # Recheck the environment variable
            FRONTEND_ENV_AFTER=$(gcloud run services describe ${{ env.FRONTEND_SERVICE }} --region=${{ env.REGION }} \
              --format="value(spec.template.spec.containers[0].env)")
            ACTUAL_API_URL_AFTER=$(echo "$FRONTEND_ENV_AFTER" | sed -n "s/.*'NEXT_PUBLIC_API_URL', 'value': '\([^']*\)'.*/\1/p")
            
            if [ "$ACTUAL_API_URL_AFTER" = "$BACKEND_URL" ]; then
              echo "âœ… Environment variable fixed after Terraform reapply: $ACTUAL_API_URL_AFTER"
            else
              echo "âŒ Environment variable still wrong after Terraform reapply"
              echo "Expected: $BACKEND_URL"
              echo "Found: $ACTUAL_API_URL_AFTER"
              exit 1
            fi
          fi
        
        # Check backend environment variables
        echo "ðŸ” Checking backend environment variables..."
        BACKEND_ENV=$(gcloud run services describe ${{ env.BACKEND_SERVICE }} --region=${{ env.REGION }} \
          --format="value(spec.template.spec.containers[0].env)")
        
        echo "Raw backend environment variables: $BACKEND_ENV"
        
        # Verify CORS_ORIGINS is set
        if echo "$BACKEND_ENV" | grep -q "CORS_ORIGINS"; then
          echo "âœ… Backend CORS_ORIGINS is configured"
        else
          echo "âŒ Backend CORS_ORIGINS is missing"
          exit 1
        fi
        
        echo "âœ… All environment variables are properly configured and persistent"
        
    - name: Check Terraform state
      run: |
        echo "Checking Terraform state for environment variable configuration..."
        cd infrastructure
        
        # Check if Terraform is initialized
        if [ -f ".terraform/terraform.tfstate" ]; then
          echo "Local Terraform state found, checking configuration..."
          terraform show | grep -A 10 -B 5 "NEXT_PUBLIC_API_URL" || echo "NEXT_PUBLIC_API_URL not found in Terraform state"
        else
          echo "No local Terraform state found"
        fi
        
        # Check if there's a remote state
        if [ -f "terraform.tf" ] && grep -q "backend \"gcs\"" terraform.tf; then
          echo "Remote state configured, checking if backend is accessible..."
          terraform state list | head -5 || echo "Cannot access remote state"
        fi
        
        echo "If environment variables are missing, run: terraform apply -auto-approve"
        
    - name: Verify configuration
      run: |
        BACKEND_URL="${{ steps.urls.outputs.backend-url }}"
        FRONTEND_URL="${{ steps.urls.outputs.frontend-url }}"

        echo "Verifying service configuration..."
        echo "Expected Backend URL: $BACKEND_URL"
        echo "Expected Frontend URL: $FRONTEND_URL"
        
        # Frontend env correctness
        echo "Checking frontend NEXT_PUBLIC_API_URL..."
        FE_ENV=$(gcloud run services describe ${{ env.FRONTEND_SERVICE }} --region=${{ env.REGION }} \
          --format="value(spec.template.spec.containers[0].env)")
        echo "Frontend environment variables: $FE_ENV"
        
        # Extract the actual NEXT_PUBLIC_API_URL value from the formatted output
        # The format is: 'name': 'NEXT_PUBLIC_API_URL', 'value': 'actual_url'
        ACTUAL_URL=$(echo "$FE_ENV" | sed -n "s/.*'NEXT_PUBLIC_API_URL', 'value': '\([^']*\)'.*/\1/p")
        
        if [ -n "$ACTUAL_URL" ]; then
          echo "Found NEXT_PUBLIC_API_URL: $ACTUAL_URL"
          echo "Expected NEXT_PUBLIC_API_URL: $BACKEND_URL"
          
          if [ "$ACTUAL_URL" = "$BACKEND_URL" ]; then
            echo "âœ… Frontend has correct backend URL configured"
          else
            echo "âŒ NEXT_PUBLIC_API_URL mismatch"
            echo "Expected: $BACKEND_URL"
            echo "Found: $ACTUAL_URL"
            exit 1
          fi
        else
          echo "âŒ NEXT_PUBLIC_API_URL environment variable not found"
          echo "Raw environment variables: $FE_ENV"
          exit 1
        fi

        # Backend CORS includes frontend URL (string match in env)
        echo "Checking backend CORS configuration..."
        BE_ENV=$(gcloud run services describe ${{ env.BACKEND_SERVICE }} --region=${{ env.REGION }} \
          --format="value(spec.template.spec.containers[0].env)")
        echo "Backend environment variables: $BE_ENV"
        
        # Check if CORS_ORIGINS is configured
        if echo "$BE_ENV" | grep -q "CORS_ORIGINS"; then
          echo "âœ… CORS_ORIGINS is configured"
          
          # Extract the actual CORS_ORIGINS value
          CORS_ORIGINS=$(echo "$BE_ENV" | sed -n "s/.*'CORS_ORIGINS', 'value': '\([^']*\)'.*/\1/p")
          if [ -n "$CORS_ORIGINS" ]; then
            echo "CORS_ORIGINS value: $CORS_ORIGINS"
            
            # Check if frontend URL is explicitly listed
            if echo "$CORS_ORIGINS" | grep -q "$FRONTEND_URL"; then
              echo "âœ… Frontend URL explicitly listed in CORS_ORIGINS"
            else
              echo "â„¹ï¸  Frontend URL not explicitly listed (wildcards may be used)"
              echo "Frontend URL: $FRONTEND_URL"
              echo "CORS_ORIGINS: $CORS_ORIGINS"
            fi
          else
            echo "âš ï¸  CORS_ORIGINS found but value could not be extracted"
          fi
        else
          echo "âŒ CORS_ORIGINS not set"
          exit 1
        fi

    - name: Create deployment summary
      run: |
        echo "## âœ… Post-Deployment Verification Passed" >> $GITHUB_STEP_SUMMARY
        echo "**Backend:** ${{ steps.urls.outputs.backend-url }}" >> $GITHUB_STEP_SUMMARY
        echo "**Frontend:** ${{ steps.urls.outputs.frontend-url }}" >> $GITHUB_STEP_SUMMARY
        echo "**Security:** Backend blocks unauth (403); passes with service account" >> $GITHUB_STEP_SUMMARY
        echo "**Functionality:** /health and /api/v1/process-text OK (authenticated)" >> $GITHUB_STEP_SUMMARY
        echo "**Config:** NEXT_PUBLIC_API_URL correct; CORS set" >> $GITHUB_STEP_SUMMARY
