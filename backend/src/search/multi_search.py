"""Multi-sub-query web search orchestration for Stage 3.

This module coordinates running web searches for each decomposed query
generated by the LangChain client. It aggregates results, deduplicates URLs,
and preserves ordering so later stages can perform content extraction and LLM
synthesis.
"""

from dataclasses import dataclass, field
import logging
from typing import Dict, Iterable, List, Optional, Sequence

from src.services.web_search import (
    WebSearchResult,
    WebSearchService,
    create_web_search_service,
)

logger = logging.getLogger(__name__)


@dataclass
class PerQuerySearchOutcome:
    """Container for results and errors from a single sub-query search."""

    query: str
    results: List[WebSearchResult] = field(default_factory=list)
    error: Optional[str] = None

    def as_dict(self) -> Dict[str, object]:
        """Return a JSON-serializable representation."""

        return {
            "query": self.query,
            "results": [result.to_dict() for result in self.results],
            "error": self.error,
        }


@dataclass
class MultiSearchResponse:
    """Aggregated outcome returned from the multi-query orchestrator."""

    sub_queries: List[str]
    per_query_outcomes: List[PerQuerySearchOutcome]
    aggregated_urls: List[str]

    def as_dict(self) -> Dict[str, object]:
        """Return JSON-serializable payload for future API integration."""

        return {
            "sub_queries": self.sub_queries,
            "per_query": [outcome.as_dict() for outcome in self.per_query_outcomes],
            "aggregated_urls": self.aggregated_urls,
        }


class MultiQuerySearchOrchestrator:
    """Execute web searches for multiple sub-queries and aggregate results."""

    def __init__(
        self,
        web_search_service: Optional[WebSearchService] = None,
    ) -> None:
        self._web_search_service = web_search_service or create_web_search_service()

    async def run(
        self,
        sub_queries: Sequence[str],
        per_query_results: int,
        max_total_results: int,
    ) -> MultiSearchResponse:
        """Run web searches for each query and aggregate outcomes."""

        sanitized_queries = [query.strip() for query in sub_queries if query.strip()]
        if not sanitized_queries:
            return MultiSearchResponse([], [], [])

        outcomes: List[PerQuerySearchOutcome] = []
        aggregated_urls: List[str] = []
        seen_urls = set()

        for query in sanitized_queries:
            outcome = await self._search_single_query(
                query, per_query_results
            )
            outcomes.append(outcome)

            for result in outcome.results:
                url = result.url.strip()
                if not url or url in seen_urls:
                    continue
                aggregated_urls.append(url)
                seen_urls.add(url)
                if len(aggregated_urls) >= max_total_results:
                    break

            if len(aggregated_urls) >= max_total_results:
                logger.debug(
                    "Reached max_total_results=%s; stopping aggregation",
                    max_total_results,
                )
                break

        return MultiSearchResponse(
            sub_queries=list(sanitized_queries),
            per_query_outcomes=outcomes,
            aggregated_urls=aggregated_urls,
        )

    async def _search_single_query(
        self, query: str, per_query_results: int
    ) -> PerQuerySearchOutcome:
        """Execute the provider search for a single sub-query."""

        outcome = PerQuerySearchOutcome(query=query)

        try:
            results = await self._web_search_service.search(
                query, max_results=per_query_results
            )
            outcome.results = results
        except Exception as exc:  # pragma: no cover - service handles logging
            logger.error("Web search failed for sub-query '%s'", query, exc_info=exc)
            outcome.error = str(exc)

        return outcome

